<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="UTF-8" />
        <title>Auto Perspektivkorrektur (OpenCV.js)</title>
        <script
            async
            src="https://docs.opencv.org/4.x/opencv.js"
            type="text/javascript"
        ></script>
        <style>
            canvas {
                border: 1px solid #ccc;
                margin: 10px;
                max-width: 100%;
                height: auto;
            }
        </style>
    </head>
    <body>
        <h2>Automatische Perspektivkorrektur für Präsentationen</h2>
        <input type="file" id="fileInput" />
        <br />
        <canvas id="srcCanvas"></canvas>
        <canvas id="dstCanvas" width="1280" height="720"></canvas>

        <script>
            let srcCanvas = document.getElementById("srcCanvas");
            let dstCanvas = document.getElementById("dstCanvas");
            let fileInput = document.getElementById("fileInput");

            fileInput.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const img = new Image();
                img.onload = async () => {
                    cv = cv instanceof Promise ? await cv : cv;

                    srcCanvas.width = img.width;
                    srcCanvas.height = img.height;
                    dstCanvas.width = img.width;
                    dstCanvas.height = img.height;
                    const ctx = srcCanvas.getContext("2d");
                    ctx.drawImage(img, 0, 0);
                    detectTrapezoidScreen();
                };
                img.src = URL.createObjectURL(file);
            });

            function detectAndTransform() {
                const src = cv.imread(srcCanvas);
                const gray = new cv.Mat();
                const blurred = new cv.Mat();
                const edged = new cv.Mat();
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();

                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                cv.Canny(blurred, edged, 50, 150);

                cv.findContours(
                    edged,
                    contours,
                    hierarchy,
                    cv.RETR_LIST,
                    cv.CHAIN_APPROX_SIMPLE
                );

                let allRects = [];
                let bestRect = null;
                let bestScore = 0;

                for (let i = 0; i < contours.size(); i++) {
                    let cnt = contours.get(i);
                    let peri = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.1 * peri, true);

                    if (approx.rows === 4) {
                        const area = cv.contourArea(approx);
                        const pts = [];

                        for (let j = 0; j < 4; j++) {
                            const pt = approx.intPtr(j, 0);
                            pts.push({ x: pt[0], y: pt[1] });
                        }

                        const ordered = orderPoints(pts);
                        const width = Math.hypot(
                            ordered[1].x - ordered[0].x,
                            ordered[1].y - ordered[0].y
                        );
                        const height = Math.hypot(
                            ordered[3].x - ordered[0].x,
                            ordered[3].y - ordered[0].y
                        );
                        const ratio = width / height;
                        const score = area * similarityToRatio(ratio, 16 / 9);

                        allRects.push({ ordered, score });

                        if (score > bestScore) {
                            bestScore = score;
                            bestRect = ordered;
                        }
                    }
                }

                if (bestRect) {
                    // Rechteck einzeichnen
                    allRects.forEach((rect) => {
                        const pts = rect.ordered;
                        for (let i = 0; i < 4; i++) {
                            const pt1 = new cv.Point(pts[i].x, pts[i].y);
                            const pt2 = new cv.Point(
                                pts[(i + 1) % 4].x,
                                pts[(i + 1) % 4].y
                            );
                            cv.line(
                                src,
                                pt1,
                                pt2,
                                new cv.Scalar(0, 255, 0, 255),
                                2
                            );
                        }
                    });
                    // for (let i = 0; i < 4; i++) {
                    //     const pt1 = new cv.Point(bestRect[i].x, bestRect[i].y);
                    //     const pt2 = new cv.Point(
                    //         bestRect[(i + 1) % 4].x,
                    //         bestRect[(i + 1) % 4].y
                    //     );
                    //     cv.line(
                    //         src,
                    //         pt1,
                    //         pt2,
                    //         new cv.Scalar(255, 0, 0, 255),
                    //         4
                    //     );
                    // }
                    cv.imshow(srcCanvas, src); // Bild mit eingezeichnetem Rechteck anzeigen
                } else {
                    alert("Kein passendes Rechteck gefunden.");
                }

                // Cleanup
                src.delete();
                gray.delete();
                blurred.delete();
                edged.delete();
                contours.delete();
                hierarchy.delete();
            }

            async function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            async function detectLargestContour() {
                const src = cv.imread(srcCanvas);
                const gray = new cv.Mat();
                const thresh = new cv.Mat();
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();

                // Vorbereitung
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                // Kontrast und Helligkeit anpassen
                let alpha = 1.5; // Kontrastfaktor (1.0 = unverändert)
                let beta = -150; // Helligkeit (0 = unverändert)
                gray.convertTo(gray, -1, alpha, beta);

                cv.imshow(srcCanvas, gray); // Zeige das Bild mit Kontrastanpassung

                cv.adaptiveThreshold(
                    gray,
                    thresh,
                    255,
                    cv.ADAPTIVE_THRESH_MEAN_C,
                    cv.THRESH_BINARY_INV,
                    25,
                    5
                );

                // Optional: Morphological Close
                const kernel = cv.Mat.ones(5, 5, cv.CV_8U);
                cv.morphologyEx(thresh, thresh, cv.MORPH_CLOSE, kernel);
                kernel.delete();

                // Konturen finden
                cv.findContours(
                    thresh,
                    contours,
                    hierarchy,
                    cv.RETR_EXTERNAL,
                    cv.CHAIN_APPROX_SIMPLE
                );

                let maxArea = 0;
                let maxContour = null;

                for (let i = 0; i < contours.size(); i++) {
                    const cnt = contours.get(i);
                    const area = cv.contourArea(cnt);

                    if (area > maxArea) {
                        maxArea = area;
                        maxContour = cnt;
                    }
                }

                // console.log(contours.get(0));

                // let allContours = [];
                // let bestContour = null;
                // let bestScore = 0;
                // const minArea = src.cols * src.rows * 0.1;

                // for (let i = 0; i < contours.size(); i++) {
                //     let cnt = contours.get(i);
                //     const area = cv.contourArea(cnt);

                //     if (area < minArea) continue;

                //     let peri = cv.arcLength(cnt, true);
                //     let approx = new cv.Mat();
                //     cv.approxPolyDP(cnt, approx, 0.04 * peri, true); // großzügiger!

                //     if (approx.rows === 4 && cv.isContourConvex(approx)) {
                //         const pts = [];
                //         for (let j = 0; j < 4; j++) {
                //             const pt = approx.intPtr(j, 0);
                //             pts.push({ x: pt[0], y: pt[1] });
                //         }

                //         const ordered = orderPoints(pts);
                //         const width = Math.hypot(
                //             ordered[1].x - ordered[0].x,
                //             ordered[1].y - ordered[0].y
                //         );
                //         const height = Math.hypot(
                //             ordered[3].x - ordered[0].x,
                //             ordered[3].y - ordered[0].y
                //         );
                //         const ratio = width / height;
                //         const similarity =
                //             1 - Math.abs(ratio - 16 / 9) / (16 / 9);
                //         const score = area * similarity;

                //         allContours.push(approx);
                //         if (score > bestScore) {
                //             bestScore = score;
                //             bestContour = approx;
                //         } else {
                //             approx.delete();
                //         }
                //     } else {
                //         approx.delete();
                //     }
                // }

                // allContours.forEach((cnt) => {
                //     const color = new cv.Scalar(255, 0, 0, 255); // blau
                //     const singleContour = new cv.MatVector();
                //     singleContour.push_back(cnt);
                //     cv.drawContours(src, singleContour, -1, color, 4);
                //     singleContour.delete();
                // });

                if (maxContour) {
                    drawContour(maxContour, src);
                } else {
                    alert("Keine Kontur gefunden.");
                }

                cv.imshow(srcCanvas, src);

                // Cleanup
                src.delete();
                gray.delete();
                thresh.delete();
                contours.delete();
                hierarchy.delete();
            }

            async function detectTrapezoidScreen() {
                const src = cv.imread(srcCanvas);
                const gray = new cv.Mat();
                const thresh = new cv.Mat();
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();

                // Graustufen & Kontrast
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                gray.convertTo(gray, -1, 1.5, -100);

                // Adaptive Threshold + Morph
                cv.adaptiveThreshold(
                    gray,
                    thresh,
                    255,
                    cv.ADAPTIVE_THRESH_MEAN_C,
                    cv.THRESH_BINARY_INV,
                    25,
                    5
                );
                const kernel = cv.Mat.ones(5, 5, cv.CV_8U);
                cv.morphologyEx(thresh, thresh, cv.MORPH_CLOSE, kernel);
                kernel.delete();

                // Konturen finden
                cv.findContours(
                    thresh,
                    contours,
                    hierarchy,
                    cv.RETR_EXTERNAL,
                    cv.CHAIN_APPROX_SIMPLE
                );

                const minArea = src.cols * src.rows * 0.1;
                let allApprox = [];
                let bestApprox = null;
                let bestArea = 0;

                console.log(contours.size());

                for (let i = 0; i < contours.size(); i++) {
                    const cnt = contours.get(i);
                    const area = cv.contourArea(cnt);
                    // if (area < minArea) continue;

                    const peri = cv.arcLength(cnt, true);
                    const approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.05 * peri, true); // toleranter für Trapeze

                    if (approx.rows >= 4 && cv.isContourConvex(approx)) {
                        drawApprox(approx, src, new cv.Scalar(255, 0, 0, 255));
                        cv.imshow(srcCanvas, src);
                        if (area > bestArea) {
                            bestArea = area;
                            if (bestApprox) bestApprox.delete();
                            bestApprox = approx;
                        } else {
                            approx.delete();
                        }
                    } else {
                        approx.delete();
                    }
                }

                // Beste Form zeichnen
                if (bestApprox) {
                    const pts = [];
                    for (let i = 0; i < 4; i++) {
                        const pt = bestApprox.intPtr(i, 0);
                        pts.push(new cv.Point(pt[0], pt[1]));
                    }

                    for (let i = 0; i < 4; i++) {
                        cv.line(
                            src,
                            pts[i],
                            pts[(i + 1) % 4],
                            new cv.Scalar(0, 255, 0, 255),
                            4
                        );
                    }

                    console.log("Trapez-Ecken:", pts); // Punkte im JS für Weiterverwendung
                    bestApprox.delete();
                } else {
                    alert("Kein Trapez gefunden.");
                }

                cv.imshow(srcCanvas, src);
                src.delete();
                gray.delete();
                thresh.delete();
                contours.delete();
                hierarchy.delete();
            }

            function drawApprox(
                approx,
                src,
                color = new cv.Scalar(0, 255, 0, 255)
            ) {
                console.count("Approx");
                const pts = [];
                for (let i = 0; i < 4; i++) {
                    const pt = approx.intPtr(i, 0);
                    pts.push(new cv.Point(pt[0], pt[1]));
                }

                for (let i = 0; i < 4; i++) {
                    cv.line(src, pts[i], pts[(i + 1) % 4], color, 4);
                }
            }

            function drawContour(cnt, src) {
                console.count("Draw");
                const color = new cv.Scalar(0, 255, 0, 255); // grün
                const singleContour = new cv.MatVector();
                singleContour.push_back(cnt);
                cv.drawContours(src, singleContour, -1, color, 4);
                singleContour.delete();
            }

            function similarityToRatio(ratio, target) {
                return 1 - Math.abs(ratio - target) / target; // Je näher an Ziel, desto besser
            }

            function orderPoints(pts) {
                // Sortiert Punkte: oben links, oben rechts, unten rechts, unten links
                pts.sort((a, b) => a.x + a.y - (b.x + b.y));
                let [tl, br] = [pts[0], pts[3]];
                let remaining = [pts[1], pts[2]];
                let [tr, bl] = remaining.sort((a, b) => a.y - b.y);
                return [tl, tr, br, bl];
            }

            function transformPerspective(src, ordered) {
                const dsize = new cv.Size(1280, 720); // 16:9
                const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    ordered[0].x,
                    ordered[0].y,
                    ordered[1].x,
                    ordered[1].y,
                    ordered[2].x,
                    ordered[2].y,
                    ordered[3].x,
                    ordered[3].y,
                ]);
                const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    0,
                    0,
                    dsize.width,
                    0,
                    dsize.width,
                    dsize.height,
                    0,
                    dsize.height,
                ]);

                const M = cv.getPerspectiveTransform(srcTri, dstTri);
                const dst = new cv.Mat();
                cv.warpPerspective(
                    src,
                    dst,
                    M,
                    dsize,
                    cv.INTER_LINEAR,
                    cv.BORDER_CONSTANT,
                    new cv.Scalar()
                );
                cv.imshow(dstCanvas, dst);

                srcTri.delete();
                dstTri.delete();
                M.delete();
                dst.delete();
            }
        </script>
    </body>
</html>
